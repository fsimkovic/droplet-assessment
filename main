#!/usr/bin/env python

__author__ = "Felix Simkovic"
__date__ = "16 Apr 2018"
__version__ = "0.1"

import av
import logging
import numpy as np
import matplotlib.collections as mcoll
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
import sys

from skimage import color
from skimage.draw import circle_perimeter
from skimage.feature import canny
from skimage.io import imread
from skimage.transform import hough_circle, hough_circle_peaks
from skimage.util import img_as_ubyte

from skvideo.io import LibAVWriter, vreader

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger()


class Video(object):
    def __init__(self, path):
        self.path = path


class VideoInSk(Video):
    def __init__(self, path):
        logger.info("Instantiated Skimage video reader")
        super(VideoInSk, self).__init__(path)

    @property
    def frames(self):
        for frame in vreader(self.path):
            yield frame


class VideoOutSk(Video):
    def __init__(self, path):
        super(VideoOutSk, self).__init__(path)
        self._container = LibAVWriter(path)
        self._lock = False

    def add(self, frame):
        if self._lock:
            raise RuntimeError("Video is locked!")
        self._container.writeFrame(frame)

    def save(self):
        self._container.close()
        self._lock = True
 

def imshow(frame, cmap=plt.cm.gray):
    fig, ax = plt.subplots()
    ax.imshow(frame, cmap=cmap)
    plt.show()


def determine_bubble_sizes_in_img(frame, debug=False):
    if debug:
        imshow(frame)

    grayscale = color.rgb2gray(frame)
    if debug:
        imshow(grayscale)

    box = [650, 450, 50, 150]  # x, y, width, height
    subframe = grayscale[box[1]:box[1]+box[3], box[0]:box[0]+box[2]]
    if debug:
        imshow(subframe)

    edges = canny(subframe, sigma=3)
    if debug:
        imshow(edges)

    hough_radii = np.arange(8, 16, 1)
    hough_res = hough_circle(edges, hough_radii)
    _, cx, cy, radii = hough_circle_peaks(hough_res, hough_radii, total_num_peaks=1)

    for center_x, center_y, radius in zip(cx, cy, radii):
        circy, circx = circle_perimeter(center_y, center_x, radius)
        frame[circy + box[1], circx + box[0]] = (220, 20, 20)
    
    if debug:
        imshow(frame)

    return radii, frame


if __name__ == "__main__":
    import argparse

    p = argparse.ArgumentParser()
    p.add_argument("--debug", default=False, action="store_true")
    p.add_argument("-o", "--output", help="Path for the output video file")
    p.add_argument("videos", nargs="+", help="Path to a video file")
    args = p.parse_args()
    

    radii_per_video_per_frame = []
    for video in args.videos:
        #  vidout = VideoOutSk(video + "out.mp4")
        radii_per_video_per_frame.append([])
        for index, frame in enumerate(VideoInSk(video).frames):
            if index % 2 > 0:
                continue
            logger.info("Processing video frame %d", index)
            radii, frame_ = determine_bubble_sizes_in_img(frame, debug=args.debug)
            radii_per_video_per_frame[-1].extend(radii)
            #  vidout.add(frame_)
        #  vidout.save()

    fig, ax = plt.subplots()
    ax.hist(radii_per_video_per_frame, bins=np.arange(5, 21))
    fig.savefig("test.png", dpi=600)
